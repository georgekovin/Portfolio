# ---------------------------------------------------------------------------------------------------------------------
# ЗАДАНИЕ 1. 
# ---------------------------------------------------------------------------------------------------------------------

def partition(n):
    '''
    Алгоритм представляет собой рекурсивную функцию на языке Python. 
    Функция принимает некоторое натуральное число и возвращает
    разбиение этого числа на другие числа.
    '''

    # каждое значение в ответе должно быть уникальным
    answer = set()
    
    # во множество добавляется кортеж из числел, которые дают в сумме `number`
    # первым делом добавляется сам `number`
    answer.add((n, ))
    
    # запускаются 2 цикла, в котором вызывается эта же функция
    for x in range(1, n):
        for y in partition(n - x):
            # во множество добавляется кортеж с числами
            answer.add(tuple(sorted((x, ) + y)))
            
    return answer


# эта функция находит количество всех полученных комбинаций
n_partitions = lambda n: len(partition(n))

n_partitions(6)
### 11


# ---------------------------------------------------------------------------------------------------------------------
# ЗАДАНИЕ 2. 
# ---------------------------------------------------------------------------------------------------------------------

def muldecomp(i):
    '''
    Разложение числа на все возможные делители
    '''
    
    # создается список чисел от 2 до самого числа не включительно, 
    # так как деление на 1 и самого себя бесполезно
    d_lst = list(range(2, i))
    j_lst = []
    
    # если заданное число делится без остатка, то оно добавляется в список
    for d in d_lst:
        if i % d == 0:
            j_lst.append(d)
    
    return j_lst


def greatest_common_divisor(lst):
    '''
    Нахождение наибольшего общего делителя у 
    неограниченного количества чисел в списке
    '''
    
    # полученные возможные делители каждого из чисел 
    # добавляются в список как множества
    sets = []
    for i in lst:
        sets.append(set(muldecomp(i)))
    
    # находим пересечение всех полученных множеств
    s_intsec = list(set.intersection(*sets))
    
    # если множества не пересекаются, то наибольшим делителем является 1
    if len(s_intsec) == 0:
        return 1
    
    # если числа имеют один общий множитель, то он и является наибольшим
    if len(s_intsec) == 1:
        return s_intsec[0]
    
    # возвращаем наибольший из найденых общих делителей
    return max(s_intsec)


greatest_common_divisor([12, 16, 32, 128])
### 4